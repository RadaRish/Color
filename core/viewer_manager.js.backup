export default class ViewerManager {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.aframeScene = null;
        this.aframeCamera = null;
        this.aframeSky = null;
        this.currentPanorama = null;
        this.zoomSpeed = 1.0; // Скорость зума по умолчанию
        
        this.initializeViewer();
    }

    initializeViewer() {
        // Инициализируем A-Frame сцену
        this.initializeAFrame();
        
        // Регистрируем компонент billboard для правильной ориентации текста
        if (!AFRAME.components['billboard']) {
            AFRAME.registerComponent('billboard', {
                tick: function () {
                    const camera = this.el.sceneEl.camera;
                    if (camera) {
                        this.el.object3D.lookAt(camera.getWorldPosition(new THREE.Vector3()));
                    }
                }
            });
        }

        // Регистрируем компонент hotspot-handler для обработки взаимодействий
        if (typeof AFRAME !== 'undefined') {
            AFRAME.registerComponent('hotspot-handler', {
                schema: {
                    hotspotId: {type: 'string'},
                    hotspotTitle: {type: 'string'},
                    hotspotType: {type: 'string'}
                },
                init: function () {
                    const el = this.el;
                    const data = this.data;
                    console.log('Инициализация hotspot-handler для:', data.hotspotTitle);
                    
                    // Обработчики событий от raycaster
                    el.addEventListener('raycaster-intersected', (e) => {
                        console.log('Raycaster intersected:', data.hotspotTitle);
                        el.emit('mouseenter');
                    });
                    
                    el.addEventListener('raycaster-intersected-cleared', (e) => {
                        console.log('Raycaster cleared:', data.hotspotTitle);
                        el.emit('mouseleave');
                    });
                    
                    // Обработчики событий
                    el.addEventListener('mouseenter', (e) => {
                        console.log('A-Frame mouseenter:', data.hotspotTitle);
                        // Показываем tooltip
                        const markerEl = el.parentElement;
                        const textContainer = markerEl.querySelector('a-entity');
                        if (textContainer) {
                            const text = textContainer.querySelector('a-text');
                            const textBackground = textContainer.querySelectorAll('a-plane')[1];
                            const textBorder = textContainer.querySelectorAll('a-plane')[0];
                            
                            if (text) {
                                text.setAttribute('visible', 'true');
                                if (textBackground) textBackground.setAttribute('visible', 'true');
                                if (textBorder) textBorder.setAttribute('visible', 'true');
                                console.log('Tooltip показан через A-Frame компонент');
                            }
                        }
                    });
                    
                    el.addEventListener('mouseleave', (e) => {
                        console.log('A-Frame mouseleave:', data.hotspotTitle);
                        // Скрываем tooltip
                        const markerEl = el.parentElement;
                        const textContainer = markerEl.querySelector('a-entity');
                        if (textContainer) {
                            const text = textContainer.querySelector('a-text');
                            const textBackground = textContainer.querySelectorAll('a-plane')[1];
                            const textBorder = textContainer.querySelectorAll('a-plane')[0];
                            
                            if (text) {
                                text.setAttribute('visible', 'false');
                                if (textBackground) textBackground.setAttribute('visible', 'false');
                                if (textBorder) textBorder.setAttribute('visible', 'false');
                                console.log('Tooltip скрыт через A-Frame компонент');
                            }
                        }
                    });
                    
                    el.addEventListener('click', (e) => {
                        console.log('A-Frame click:', data.hotspotTitle, data.hotspotType);
                        // Находим данные хотспота и вызываем соответствующую функцию
                        const hotspotId = data.hotspotId;
                        const hotspot = window.hotspotManager ? window.hotspotManager.findHotspotById(hotspotId) : null;
                        
                        if (hotspot) {
                            if (hotspot.type === 'hotspot' && hotspot.targetSceneId) {
                                console.log('Переключение на сцену:', hotspot.targetSceneId);
                                window.sceneManager.switchToScene(hotspot.targetSceneId);
                            } else if (hotspot.type === 'info-point') {
                                console.log('Показ модального окна для инфоточки');
                                window.viewerManager.showInfoPointModal(hotspot);
                            }
                        }
                    });
                }
            });
        }
    }

    initializeAFrame() {
        // Создаем A-Frame сцену
        this.aframeScene = document.createElement('a-scene');
        this.aframeScene.setAttribute('embedded', 'true');
        this.aframeScene.setAttribute('style', 'width: 100%; height: 100%; cursor: grab;');
        this.aframeScene.setAttribute('cursor', 'rayOrigin: mouse');
        this.aframeScene.setAttribute('raycaster', 'objects: .interactive');
        this.aframeScene.setAttribute('vr-mode-ui', 'enabled: false');
        
        // Создаем assets для шрифтов
        const assets = document.createElement('a-assets');
        
        // Добавляем кастомный шрифт для поддержки кириллицы
        const fontAsset = document.createElement('a-mixin');
        fontAsset.setAttribute('id', 'cyrillic-font');
        fontAsset.setAttribute('text', 'font: roboto; shader: sdf');
        assets.appendChild(fontAsset);
        
        this.aframeScene.appendChild(assets);

        // Создаем камеру
        const camera = document.createElement('a-entity');
        camera.setAttribute('camera', 'fov: 80; zoom: 1');
        camera.setAttribute('look-controls', 'enabled: true');
        camera.setAttribute('wasd-controls', 'enabled: false');
        camera.id = 'camera';
        this.aframeScene.appendChild(camera);

        // Создаем курсор
        const cursor = document.createElement('a-cursor');
        cursor.setAttribute('animation__click', 'property: scale; startEvents: click; from: 0.1 0.1 0.1; to: 1 1 1; dur: 150');
        cursor.setAttribute('animation__fusing', 'property: scale; startEvents: fusing; from: 1 1 1; to: 0.1 0.1 0.1; dur: 1500');
        cursor.setAttribute('raycaster', 'objects: .interactive');
        camera.appendChild(cursor);

        // Добавляем сцену в контейнер
        this.container.appendChild(this.aframeScene);
        
        console.log('A-Frame сцена инициализирована с поддержкой кириллицы');
    }
    }

    async setPanorama(imageSrc) {
        if (!this.aframeSky) return false;
        
        try {
            // Устанавливаем источник изображения для панорамы
            this.aframeSky.setAttribute('src', imageSrc);
            this.currentPanorama = imageSrc;
            console.log('Панорама загружена:', imageSrc);
            return true;
        } catch (error) {
            console.error('Ошибка при загрузке панорамы:', error);
            return false;
        }
    }

    setupEventHandlers() {
        // Обработка правого клика для контекстного меню
        this.container.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            this.showContextMenu(e.clientX, e.clientY, e);
        });

        // Закрытие контекстного меню при обычном клике
        this.container.addEventListener('click', () => {
            this.hideContextMenu();
        });
    }

    showContextMenu(x, y, event) {
        this.hideContextMenu(); // Убираем предыдущее меню
        
        const menu = document.createElement('div');
        menu.className = 'custom-context-menu';
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        
        menu.innerHTML = `
            <button data-type="hotspot">Добавить хотспот</button>
            <button data-type="info-point">Добавить инфоточку</button>
        `;
        
        document.body.appendChild(menu);
        
        // Обработчики для кнопок меню
        menu.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.dataset.type;
                
                // Получаем 3D координаты клика
                const intersection = this.getIntersectionPoint(event);
                if (!intersection) {
                    console.warn("Не удалось определить точку пересечения.");
                    return;
                }

                // Вызываем событие для main.js
                const customEvent = new CustomEvent('context-menu-add-hotspot', {
                    detail: { type, position: `${intersection.x} ${intersection.y} ${intersection.z}` }
                });
                this.container.dispatchEvent(customEvent);

                menu.remove();
            });
        });

        // Закрытие меню при клике вне его
        setTimeout(() => {
            const closeHandler = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            document.addEventListener('click', closeHandler);
        }, 0);
    }

    hideContextMenu() {
        const existingMenu = document.querySelector('.custom-context-menu');
        if (existingMenu) {
            existingMenu.remove();
        }
    }

    getIntersectionPoint(event) {
        if (!this.aframeScene || !this.aframeCamera || !this.aframeSky) {
            return null;
        }

        // Простой способ получения координат: используем нормализованные координаты экрана
        const rect = this.container.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Преобразуем в 3D координаты на сфере
        const phi = (x * Math.PI);
        const theta = ((y + 1) * Math.PI / 2);
        
        const radius = 10; // Радиус для размещения маркеров
        const position = {
            x: radius * Math.sin(theta) * Math.cos(phi),
            y: radius * Math.cos(theta),
            z: radius * Math.sin(theta) * Math.sin(phi)
        };
        
        return position;
    }

    createVisualMarker(hotspot) {
        if (!this.aframeScene) return;

        const markerEl = document.createElement('a-entity');
        // Устанавливаем уникальный ID для DOM-элемента, связанный с ID хотспота
        markerEl.id = `marker-${hotspot.id}`;
        markerEl.setAttribute('data-hotspot-id', hotspot.id);
        
        // Позиционируем маркер
        markerEl.setAttribute('position', hotspot.position);

        // Делаем маркер интерактивным и перетаскиваемым
        markerEl.className = 'interactive draggable';
        
        // Важно: добавляем класс interactive и к shape для raycaster
        // Добавляем состояние для перетаскивания
        markerEl._isDragging = false;
        markerEl._tooltipVisible = false;
        
        // Получаем настройки для маркера
        const defaultSettings = this.getDefaultSettings();
        const radius = hotspot.size || (hotspot.type === 'hotspot' ? defaultSettings.hotspotSize : defaultSettings.infopointSize);
        const color = hotspot.color || (hotspot.type === 'hotspot' ? defaultSettings.hotspotColor : defaultSettings.infopointColor);
        const icon = hotspot.icon || 'sphere';
        
        // Создаем геометрию
        let shape;
        console.log('Создаем фигуру:', icon, 'размер:', radius, 'цвет:', color);
        
        // Проверяем, есть ли пользовательская иконка
        if (icon === 'custom' && hotspot.customIconData) {
            console.log('Создаем пользовательскую иконку');
            
            // Создаем плоскость для изображения
            shape = document.createElement('a-plane');
            
            // Создаем уникальный ID для текстуры
            const textureId = `custom-texture-${hotspot.id}`;
            
            // Создаем элемент img для текстуры
            const img = document.createElement('img');
            img.id = textureId;
            img.src = hotspot.customIconData;
            img.crossOrigin = 'anonymous';
            img.style.display = 'none';
            
            // Добавляем изображение в assets
            let assets = this.aframeScene.querySelector('a-assets');
            if (!assets) {
                assets = document.createElement('a-assets');
                this.aframeScene.appendChild(assets);
            }
            assets.appendChild(img);
            
            // Настраиваем материал с текстурой
            shape.setAttribute('material', {
                src: `#${textureId}`,
                transparent: true,
                alphaTest: 0.5
            });
            
            // Устанавливаем размер (для плоскости используем width и height)
            shape.setAttribute('width', radius * 2);
            shape.setAttribute('height', radius * 2);
            
            console.log('Пользовательская иконка создана с ID текстуры:', textureId);
            
        } else {
            // Создаем стандартную геометрическую фигуру
            switch (icon) {
                case 'cube':
                    shape = document.createElement('a-box');
                    shape.setAttribute('width', radius);
                    shape.setAttribute('height', radius);
                    shape.setAttribute('depth', radius);
                    break;
                case 'cylinder':
                    shape = document.createElement('a-cylinder');
                    shape.setAttribute('radius', radius);
                    shape.setAttribute('height', radius * 2);
                    break;
                case 'octahedron':
                    shape = document.createElement('a-octahedron');
                    shape.setAttribute('radius', radius);
                    break;
                default: // sphere
                    shape = document.createElement('a-sphere');
                    shape.setAttribute('radius', radius);
                    break;
            }
            
            shape.setAttribute('color', color);
            shape.setAttribute('opacity', '0.9');
            shape.setAttribute('material', 'transparent: true');
        }
        shape.className = 'interactive'; // Добавляем класс для raycaster
        
        // Добавляем наш компонент для обработки взаимодействий
        shape.setAttribute('hotspot-handler', `hotspotId: ${hotspot.id}; hotspotTitle: ${hotspot.title || 'Без названия'}; hotspotType: ${hotspot.type}`);
        
        // Анимация пульсации
        shape.setAttribute('animation__pulse', 'property: scale; to: 1.2 1.2 1.2; dir: alternate; loop: true; dur: 1000; easing: easeInOutSine;');
        
        // Анимации при наведении
        shape.setAttribute('animation__hover_on', 'property: scale; to: 1.4 1.4 1.4; startEvents: mouseenter; dur: 200;');
        shape.setAttribute('animation__hover_off', 'property: scale; to: 1 1 1; startEvents: mouseleave; dur: 200;');

        console.log('Фигура создана:', shape.tagName, shape.getAttribute('radius') || shape.getAttribute('width'));

        // Текст (название) - создаем как отдельный элемент
        const textContainer = document.createElement('a-entity');
        textContainer.setAttribute('position', '0 0.8 0'); // Над иконкой
        
        const text = document.createElement('a-text');
        text.setAttribute('value', hotspot.title || 'Без названия');
        text.setAttribute('align', 'center');
        text.setAttribute('color', hotspot.textColor || '#ffffff');
        text.setAttribute('font', 'roboto');
        text.setAttribute('width', '6');
        text.setAttribute('position', '0 0 0');
        text.setAttribute('visible', 'false');
        text.setAttribute('shader', 'sdf');
        text.setAttribute('material', 'alphaTest: 0.5');
        
        // Добавляем тень для лучшей читаемости
        const textShadow = document.createElement('a-text');
        textShadow.setAttribute('value', hotspot.title || 'Без названия');
        textShadow.setAttribute('align', 'center');
        textShadow.setAttribute('color', '#000000');
        textShadow.setAttribute('font', 'roboto');
        textShadow.setAttribute('width', '6');
        textShadow.setAttribute('position', '0.02 -0.02 -0.01'); // Смещение для тени
        textShadow.setAttribute('visible', 'false');
        textShadow.setAttribute('shader', 'sdf');
        textShadow.setAttribute('material', 'alphaTest: 0.5; opacity: 0.8');
        
        // Компонент look-at для постоянного поворота к камере
        // Убеждаемся что компонент всегда поворачивается к камере
        textContainer.setAttribute('billboard', '');
        
        textContainer.appendChild(textShadow);
        textContainer.appendChild(text);

        // События для показа/скрытия текста и перетаскивания
        console.log('Создаем события для маркера:', hotspot.id, hotspot.title);
        
        // Простой тест наведения
        markerEl.addEventListener('mouseenter', (e) => {
            console.log('MOUSEENTER на маркер:', hotspot.title);
            e.stopPropagation();
            if (!markerEl._isDragging && !markerEl._tooltipVisible) {
                text.setAttribute('visible', 'true');
                textShadow.setAttribute('visible', 'true');
                markerEl._tooltipVisible = true;
                console.log('Tooltip показан для:', hotspot.title);
            }
        });
        
        markerEl.addEventListener('mouseleave', (e) => {
            console.log('MOUSELEAVE с маркера:', hotspot.title);
            e.stopPropagation();
            if (!markerEl._isDragging && markerEl._tooltipVisible) {
                text.setAttribute('visible', 'false');
                textShadow.setAttribute('visible', 'false');
                markerEl._tooltipVisible = false;
                console.log('Tooltip скрыт для:', hotspot.title);
            }
        });

        // События для перетаскивания
        markerEl.addEventListener('mousedown', (e) => {
            console.log('MOUSEDOWN на маркер:', hotspot.title, e.button);
            if (e.button === 0) { // Левая кнопка мыши
                e.stopPropagation();
                this.startDragging(markerEl, hotspot, e);
            }
        });

        // Клик без перетаскивания - основная функция
        markerEl.addEventListener('click', (e) => {
            console.log('CLICK на маркер:', hotspot.title, 'wasDragged:', markerEl._wasDragged);
            e.stopPropagation();
            if (!markerEl._wasDragged) {
                if (hotspot.type === 'hotspot' && hotspot.targetSceneId) {
                    console.log('Переключение на сцену:', hotspot.targetSceneId);
                    window.sceneManager.switchToScene(hotspot.targetSceneId);
                } else if (hotspot.type === 'info-point') {
                    console.log('Показ модального окна для инфоточки');
                    this.showInfoPointModal(hotspot);
                }
            }
            markerEl._wasDragged = false; // Сбрасываем флаг
        });

        // Правый клик - контекстное меню для редактирования
        markerEl.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.showMarkerContextMenu(e.clientX, e.clientY, hotspot);
        });

        markerEl.appendChild(shape);
        markerEl.appendChild(textContainer);
        this.aframeScene.appendChild(markerEl);
        
        console.log('Маркер добавлен в сцену:', {
            id: markerEl.id,
            className: markerEl.className,
            position: markerEl.getAttribute('position'),
            hasShape: !!shape,
            hasTextContainer: !!textContainer,
            sceneChildren: this.aframeScene.children.length
        });
        
        // Проверяем через небольшую задержку, что элемент действительно в DOM
        setTimeout(() => {
            const checkEl = document.getElementById(`marker-${hotspot.id}`);
            console.log('Проверка маркера через 100ms:', !!checkEl, checkEl ? checkEl.className : 'не найден');
        }, 100);
    }

    showInfoPointModal(hotspot) {
        // Создаем красивое модальное окно для инфоточки
        const modal = document.createElement('div');
        modal.className = 'info-point-modal';
        modal.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid #646cff;
            border-radius: 12px;
            padding: 20px 30px;
            z-index: 10001;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 0.87);
        `;
        
        modal.innerHTML = `
            <h3 style="margin: 0 0 15px 0; color: #ffcc00;">${hotspot.title}</h3>
            <p style="margin: 0; line-height: 1.5; color: ${hotspot.textColor || '#ffffff'}; font-size: ${hotspot.textSize || '1'}em;">${hotspot.description || ''}</p>
            <button onclick="this.closest('.info-point-modal').remove()" 
                    style="margin-top: 15px; padding: 8px 16px; background: #646cff; border: none; border-radius: 4px; color: white; cursor: pointer;">
                Закрыть
            </button>
        `;
        
        document.body.appendChild(modal);
        
        // Закрытие при клике вне модального окна
        setTimeout(() => {
            const closeHandler = (e) => {
                if (!modal.contains(e.target)) {
                    modal.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            document.addEventListener('click', closeHandler);
        }, 0);
    }

    showMarkerContextMenu(x, y, hotspot) {
        // Убираем предыдущее меню
        const existingMenu = document.querySelector('.marker-context-menu');
        if (existingMenu) existingMenu.remove();
        
        const menu = document.createElement('div');
        menu.className = 'marker-context-menu custom-context-menu';
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        
        menu.innerHTML = `
            <button data-action="edit">✏️ Редактировать</button>
            <button data-action="move">📍 Переместить</button>
            <button data-action="delete" class="danger">🗑️ Удалить</button>
        `;
        
        document.body.appendChild(menu);
        
        // Обработчики для кнопок меню
        menu.querySelector('[data-action="edit"]').addEventListener('click', () => {
            window.editMarker(hotspot.id);
            menu.remove();
        });
        
        menu.querySelector('[data-action="move"]').addEventListener('click', () => {
            this.startMoveMode(hotspot);
            menu.remove();
        });
        
        menu.querySelector('[data-action="delete"]').addEventListener('click', () => {
            window.deleteMarker(hotspot.id);
            menu.remove();
        });
        
        // Закрытие меню при клике вне его
        setTimeout(() => {
            const closeHandler = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            document.addEventListener('click', closeHandler);
        }, 0);
    }

    startMoveMode(hotspot) {
        const markerEl = document.getElementById(`marker-${hotspot.id}`);
        if (!markerEl) return;
        
        // Визуальная индикация режима перемещения
        const shapeEl = markerEl.querySelector('a-sphere, a-box, a-cylinder, a-octahedron');
        if (shapeEl) {
            shapeEl.setAttribute('color', '#ff00ff');
            shapeEl.setAttribute('opacity', '0.7');
        }
        
        // Показываем инструкцию
        const instruction = document.createElement('div');
        instruction.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(26, 26, 26, 0.9);
            border: 1px solid #ff00ff;
            border-radius: 8px;
            padding: 12px 20px;
            color: rgba(255, 255, 255, 0.87);
            z-index: 10000;
        `;
        instruction.textContent = 'Кликните в новое место для перемещения маркера';
        document.body.appendChild(instruction);
        
        // Обработчик клика для нового позиционирования
        const moveHandler = (e) => {
            if (e.target.tagName === 'A-SKY') {
                const newPosition = this.getIntersectionPoint(e);
                if (newPosition) {
                    // Обновляем позицию хотспота
                    hotspot.position = `${newPosition.x} ${newPosition.y} ${newPosition.z}`;
                    window.hotspotManager.updateHotspot(hotspot.id, { position: hotspot.position });
                    
                    // Убираем обработчик и восстанавливаем вид
                    this.container.removeEventListener('click', moveHandler);
                    if (shapeEl) {
                        const defaultSettings = this.getDefaultSettings();
                        const color = hotspot.color || (hotspot.type === 'hotspot' ? defaultSettings.hotspotColor : defaultSettings.infopointColor);
                        shapeEl.setAttribute('color', color);
                        shapeEl.setAttribute('opacity', '0.9');
                    }
                    instruction.remove();
                }
            }
        };
        
        this.container.addEventListener('click', moveHandler);
    }

    updateVisualMarker(hotspot) {
        const markerEl = document.getElementById(`marker-${hotspot.id}`);
        if (!markerEl) return;

        // Если иконка изменилась, пересоздаем маркер
        const currentShape = markerEl.querySelector('a-sphere, a-box, a-cylinder, a-octahedron');
        const newIcon = hotspot.icon || 'sphere';
        const currentIcon = this.getShapeType(currentShape);
        
        if (currentIcon !== newIcon) {
            // Пересоздаем маркер с новой геометрией
            this.removeVisualMarker(hotspot.id);
            this.createVisualMarker(hotspot);
            return;
        }

        // Обновляем позицию
        markerEl.setAttribute('position', hotspot.position);
        
        // Обновляем текст
        const textContainer = markerEl.querySelector('a-entity');
        const textEl = textContainer ? textContainer.querySelector('a-text') : null;
        const textBackground = textContainer ? textContainer.querySelectorAll('a-plane')[1] : null; // второй plane - это фон
        const textBorder = textContainer ? textContainer.querySelectorAll('a-plane')[0] : null; // первый plane - это рамка
        
        if (textEl) {
            textEl.setAttribute('value', hotspot.title || 'Без названия');
            textEl.setAttribute('color', hotspot.textColor || '#ffffff');
            
            // Обновляем размер фона и рамки для текста
            const textWidth = Math.max(2, (hotspot.title || 'Без названия').length * 0.12);
            if (textBackground) {
                textBackground.setAttribute('width', textWidth);
            }
            if (textBorder) {
                textBorder.setAttribute('width', textWidth + 0.1);
            }
        }
        
        // Обновляем цвет и размер маркера
        if (currentShape) {
            const defaultSettings = this.getDefaultSettings();
            const size = hotspot.size || (hotspot.type === 'hotspot' ? defaultSettings.hotspotSize : defaultSettings.infopointSize);
            const color = hotspot.color || (hotspot.type === 'hotspot' ? defaultSettings.hotspotColor : defaultSettings.infopointColor);
            
            currentShape.setAttribute('color', color);
            
            // Устанавливаем размер в зависимости от типа геометрии
            switch (newIcon) {
                case 'cube':
                    currentShape.setAttribute('width', size);
                    currentShape.setAttribute('height', size);
                    currentShape.setAttribute('depth', size);
                    break;
                case 'cylinder':
                    currentShape.setAttribute('radius', size);
                    currentShape.setAttribute('height', size * 2);
                    break;
                default: // sphere, octahedron
                    currentShape.setAttribute('radius', size);
                    break;
            }
        }
    }

    getShapeType(element) {
        if (!element) return 'sphere';
        const tagName = element.tagName.toLowerCase();
        switch (tagName) {
            case 'a-box': return 'cube';
            case 'a-cylinder': return 'cylinder';
            case 'a-octahedron': return 'octahedron';
            default: return 'sphere';
        }
    }

    removeVisualMarker(hotspotId) {
        const markerEl = document.getElementById(`marker-${hotspotId}`);
        if (markerEl) {
            markerEl.remove();
        }
    }

    getViewer() {
        return {
            container: this.container,
            scene: this.aframeScene,
            camera: this.aframeCamera,
            sky: this.aframeSky
        };
    }

    clearMarkers() {
        const markers = this.aframeScene.querySelectorAll('[data-hotspot-id]');
        markers.forEach(marker => marker.remove());
    }

    updateCameraSettings(settings) {
        if (this.aframeCamera && settings.mouseSensitivity) {
            // Обновляем чувствительность мыши для look-controls
            const lookControls = this.aframeCamera.getAttribute('look-controls');
            this.aframeCamera.setAttribute('look-controls', {
                ...lookControls,
                mouseSensitivity: settings.mouseSensitivity,
                touchSensitivity: settings.mouseSensitivity
            });
        }
        
        // Сохраняем настройки скорости зума
        if (settings.zoomSpeed) {
            this.zoomSpeed = settings.zoomSpeed;
        }
    }

    getDefaultSettings() {
        const savedSettings = localStorage.getItem('panorama-editor-settings');
        if (savedSettings) {
            return JSON.parse(savedSettings);
        }
        return {
            mouseSensitivity: 1,
            zoomSpeed: 1.0,
            hotspotColor: '#00ff00',
            hotspotSize: 0.3,
            infopointColor: '#ff0000',
            infopointSize: 0.2
        };
    }

    setupZoomControls() {
        // Управление зумом колесиком мыши
        this.container.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const currentFov = this.aframeCamera.getAttribute('fov');
            const zoomStep = 5 * this.zoomSpeed;
            const delta = e.deltaY > 0 ? zoomStep : -zoomStep;
            let newFov = currentFov + delta;
            
            // Ограничиваем зум
            newFov = Math.max(20, Math.min(120, newFov)); // От 20 до 120 градусов
            
            this.aframeCamera.setAttribute('fov', newFov);
        });
        
        // Управление зумом кнопками + и -
        document.addEventListener('keydown', (e) => {
            if (e.key === '+' || e.key === '=') {
                this.zoomIn();
            } else if (e.key === '-') {
                this.zoomOut();
            }
        });
    }

    zoomIn() {
        const currentFov = this.aframeCamera.getAttribute('fov');
        const zoomStep = 5 * this.zoomSpeed;
        const newFov = Math.max(20, currentFov - zoomStep);
        this.aframeCamera.setAttribute('fov', newFov);
    }

    zoomOut() {
        const currentFov = this.aframeCamera.getAttribute('fov');
        const zoomStep = 5 * this.zoomSpeed;
        const newFov = Math.min(120, currentFov + zoomStep);
        this.aframeCamera.setAttribute('fov', newFov);
    }

    resetZoom() {
        this.aframeCamera.setAttribute('fov', 80);
    }

    // Методы для перетаскивания маркеров
    startDragging(markerEl, hotspot, startEvent) {
        markerEl._isDragging = true;
        markerEl._wasDragged = false;
        
        // Добавляем визуальную обратную связь
        markerEl.classList.add('dragging');
        const shape = markerEl.querySelector('a-sphere, a-box, a-cylinder, a-octahedron');
        if (shape) {
            shape.setAttribute('opacity', '0.7');
            shape.setAttribute('material', 'transparent: true');
        }
        
        // Скрываем tooltip во время перетаскивания
        const textContainer = markerEl.querySelector('a-entity');
        const text = textContainer ? textContainer.querySelector('a-text') : null;
        const textBackground = textContainer ? textContainer.querySelectorAll('a-plane')[1] : null;
        const textBorder = textContainer ? textContainer.querySelectorAll('a-plane')[0] : null;
        
        if (text && markerEl._tooltipVisible) {
            text.setAttribute('visible', 'false');
            textBackground.setAttribute('visible', 'false');
            textBorder.setAttribute('visible', 'false');
            markerEl._tooltipVisible = false;
        }

        const startPosition = this.getMarkerPosition(markerEl);
        const camera = this.aframeCamera;
        
        const onMouseMove = (e) => {
            markerEl._wasDragged = true;
            
            // Проверяем доступность THREE.js
            if (typeof THREE === 'undefined') {
                console.error('THREE.js not available for dragging');
                return;
            }
            
            // Получаем направление взгляда камеры
            const cameraRotation = camera.getAttribute('rotation');
            const cameraEl = camera.object3D;
            
            // Вычисляем новую позицию на основе движения мыши
            const sensitivity = 0.005;
            const deltaX = (e.clientX - startEvent.clientX) * sensitivity;
            const deltaY = -(e.clientY - startEvent.clientY) * sensitivity;
            
            // Преобразуем движение мыши в мировые координаты
            const right = new THREE.Vector3(1, 0, 0);
            const up = new THREE.Vector3(0, 1, 0);
            
            right.applyQuaternion(cameraEl.quaternion);
            up.applyQuaternion(cameraEl.quaternion);
            
            const newPosition = {
                x: startPosition.x + right.x * deltaX + up.x * deltaY,
                y: startPosition.y + right.y * deltaX + up.y * deltaY,
                z: startPosition.z + right.z * deltaX + up.z * deltaY
            };
            
            // Ограничиваем радиус (чтобы маркер не уходил слишком далеко)
            const distance = Math.sqrt(newPosition.x * newPosition.x + newPosition.y * newPosition.y + newPosition.z * newPosition.z);
            if (distance > 10) {
                const scale = 10 / distance;
                newPosition.x *= scale;
                newPosition.y *= scale;
                newPosition.z *= scale;
            }
            
            // Обновляем позицию маркера
            markerEl.setAttribute('position', `${newPosition.x} ${newPosition.y} ${newPosition.z}`);
            
            // Обновляем данные hotspot
            hotspot.position = `${newPosition.x} ${newPosition.y} ${newPosition.z}`;
        };

        const onMouseUp = () => {
            markerEl._isDragging = false;
            
            // Убираем визуальную обратную связь
            markerEl.classList.remove('dragging');
            const shape = markerEl.querySelector('a-sphere, a-box, a-cylinder, a-octahedron');
            if (shape) {
                shape.setAttribute('opacity', '0.9');
            }
            
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            
            // Уведомляем HotspotManager об изменении позиции
            if (window.hotspotManager && markerEl._wasDragged) {
                window.hotspotManager.updateHotspotPosition(hotspot.id, hotspot.position);
            }
        };

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    getMarkerPosition(markerEl) {
        const pos = markerEl.getAttribute('position');
        return {
            x: pos.x || 0,
            y: pos.y || 0,
            z: pos.z || 0
        };
    }
}
